# Workflow name displayed in GitHub Actions UI
name: Build Qt App (CMake + Pre-built Rust Lib) on Windows

# Triggers for this workflow
on:
  push:
    branches:
      - main # Trigger on pushes to the 'main' branch
  pull_request:
    branches:
      - main # Trigger on pull requests targeting the 'main' branch
  workflow_dispatch: # Allows manual triggering from the GitHub Actions UI

# Define a single job named 'build'
jobs:
  build:
    # Specify the runner environment for Windows
    runs-on: windows-latest

    # Steps involved in the job
    steps:
      # Step 1: Checkout the source code from the repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Install Qt for Windows.
      # Specify the desired Qt version and architecture (MSVC is common on Windows).
      - name: Install Qt for Windows
        uses: jurplel/install-qt-action@v3
        with:
          version: 6.7.0 # Explicitly specify a known stable Qt 6 version (e.g., 6.7.0).
                         # Changed from '6.x' to avoid potential issues with 'aqtinstall'
                         # trying to resolve to non-existent future versions or cached incorrect ones.
          arch: win64_msvc2019_64bit # Or win64_mingw if you use MinGW on Windows
          # modules: 'qtbase qtdeclarative' # Uncomment and add specific Qt modules if your app uses them beyond base Qt Widgets

      # Step 3: Configure the project with CMake.
      # Create a dedicated build directory for the GitHub Actions build.
      - name: Configure with CMake
        run: |
          echo "Configuring Qt project with CMake..."
          # Use cmd.exe or PowerShell commands for Windows
          mkdir build_github
          cd build_github
          # Run CMake:
          # .. points to the source directory (repository root)
          # -DCMAKE_PREFIX_PATH is crucial for CMake to find the Qt installation.
          #   ${{ env.QT_INSTALL_DIR }} and ${{ env.QT_VERSION }} are set by install-qt-action.
          #   msvc2019_64 is the standard compiler target for Windows MSVC.
          # -DCMAKE_BUILD_TYPE=Release ensures a release build.
          # Optionally specify a generator, though CMake often picks a suitable one for the environment.
          cmake .. -DCMAKE_PREFIX_PATH="${{ env.QT_INSTALL_DIR }}/${{ env.QT_VERSION }}/msvc2019_64" -DCMAKE_BUILD_TYPE=Release
          echo "CMake configuration complete."

      # Step 4: Build the project using CMake.
      - name: Build with CMake
        run: |
          echo "Building Qt project with CMake..."
          cd build_github
          # Use cmake --build . to build the project.
          # --config Release is important for Visual Studio generators.
          # -j is not directly used with MSVC; CMake handles parallel builds.
          cmake --build . --config Release
          echo "Qt project built."

      # Step 5: Run windeployqt to bundle necessary Qt DLLs and plugins.
      - name: Deploy Qt application with windeployqt
        run: |
          echo "Running windeployqt..."
          # Change to the directory where the executable is built
          cd build_github
          # Run windeployqt on your executable. It will copy required Qt DLLs and plugins.
          # The executable name should match your project (atsar.exe).
          # The windeployqt tool should be in PATH due to install-qt-action.
          windeployqt atsar.exe
          echo "windeployqt finished."

      # Step 6: Create an artifact bundle for the executable and shared library
      # This step ensures both the Qt app and its required Rust library are packaged together.
      - name: Create artifact bundle
        run: |
          echo "Creating artifact bundle..."
          # Create a temporary staging directory to collect all necessary files
          # Use PowerShell commands for Windows
          New-Item -ItemType Directory -Force staging_artifact
          # Copy the main executable (your app, named 'atsar.exe') and all its dependencies bundled by windeployqt
          Copy-Item -Path "build_github\*" -Destination "staging_artifact\" -Recurse -Force
          # Copy the pre-built Rust shared library (atsa_questions.dll for Windows)
          # Make sure your Rust library is compiled for Windows (.dll) and named correctly in your repo.
          Copy-Item -Path "atsar-rust-lib\atsa_questions.dll" -Destination "staging_artifact\" -Force

          # --- Optional: If your app needs other assets or Qt plugins ---
          # Based on your tree, you have a 'data' directory.
          # If 'atsar' needs this 'data' directory to run, copy it:
          Copy-Item -Path "data" -Destination "staging_artifact\" -Recurse -Force

          echo "Artifact bundle created in 'staging_artifact\'."

      # Step 7: Upload the compiled application and its shared library as an artifact.
      # This makes the runnable package available for download from the GitHub Actions run.
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: atsar-app-windows # A descriptive name for the downloadable artifact
          path: staging_artifact/ # Upload the entire staging directory
          # retain-days: 7 # Optional: How long to keep the artifact
